export declare let eqQ: (x: any, y: any) => boolean;
export declare let eqvQ: (x: any, y: any) => boolean;
export declare let equalQ: (x: any, y: any) => boolean;
export declare let numberQ: (n: any) => boolean;
export declare let complexQ: (n: any) => boolean;
export declare let realQ: (n: any) => boolean;
export declare let rationalQ: (n: any) => boolean;
export declare let integerQ: (n: any) => boolean;
export declare let exactQ: (n: any) => boolean;
export declare let exact_integerQ: (n: any) => boolean;
export declare let E: (...args: number[]) => boolean;
export declare let L: (...args: number[]) => boolean;
export declare let G: (...args: number[]) => boolean;
export declare let LE: (...args: number[]) => boolean;
export declare let GE: (...args: number[]) => boolean;
export declare let zeroQ: (n: number) => boolean;
export declare let positiveQ: (n: number) => boolean;
export declare let negativeQ: (n: number) => boolean;
export declare let oddQ: (n: number) => boolean;
export declare let evenQ: (n: number) => boolean;
export declare let max: (...args: number[]) => number;
export declare let min: (...args: number[]) => number;
export declare let plus: (...args: number[]) => number;
export declare let multiply: (...args: number[]) => number;
export declare let minus: (...args: number[]) => number;
export declare let divide: (...args: number[]) => number;
export declare let abs: (x: number) => number;
export declare let quotient: (x: number, y: number) => number;
export declare let modulo: (x: number, y: number) => number;
export declare let remainder: (x: number, y: number) => number;
export declare let gcd: (...args: number[]) => number;
export declare let lcm: (...args: number[]) => number;
export declare let floor: (x: number) => number;
export declare let ceiling: (x: number) => number;
export declare let truncate: (x: number) => number;
export declare let round: (x: number) => number;
export declare let rationalize: (x: number, y: number) => number;
export declare let square: (x: number) => number;
export declare let exact_integer_sqrt: (x: number) => number;
export declare let expt: (x: number, y: number) => number;
export declare let inexact: (x: number) => number;
export declare let exact: (x: number) => number;
export declare let number_Gstring: (x: number) => string;
export declare let string_Gnumber: (x: string) => number;
export declare const $true: (b: any) => boolean;
export declare let and: (...args: any[]) => boolean;
export declare let or: (...args: any[]) => boolean;
export declare let not: (b: any) => boolean;
export declare let booleanQ: (b: any) => boolean;
export declare let booleanEQ: (b1: boolean, b2: boolean) => boolean;
export declare const $list_to_array: (l: Pair) => any[];
export declare class Pair {
    car: any;
    cdr: any;
    constructor(car: any, cdr: any);
    toString(): string;
}
export declare let pairQ: (p: any) => boolean;
export declare let cons: (car: any, cdr: any) => Pair;
export declare let car: (p: Pair) => any;
export declare let cdr: (p: Pair) => any;
export declare let set_carB: (p: Pair, val: any) => void;
export declare let set_cdrB: (p: Pair, val: any) => void;
export declare let caar: (p: Pair) => any;
export declare let cadr: (p: Pair) => any;
export declare let cdar: (p: Pair) => any;
export declare let cddr: (p: Pair) => any;
export declare let nullQ: (p: any) => boolean;
export declare let listQ: (p: any) => boolean;
export declare let make_list: (n: number, val?: any) => Pair | null;
export declare let list: (...args: any[]) => Pair | null;
export declare let length: (p: Pair | null) => number;
export declare let append: (...args: (Pair | null)[]) => Pair | null;
export declare let reverse: (p: Pair | null) => Pair | null;
export declare let list_tail: (p: Pair | null, n: number) => Pair | null;
export declare let list_ref: (p: Pair | null, n: number) => any;
export declare let list_setB: (p: Pair | null, n: number, val: any) => void;
export declare let memq: (item: any, p: Pair | null) => Pair | null | boolean;
export declare let memv: (item: any, p: Pair | null) => Pair | null | boolean;
export declare let member: (item: any, p: Pair | null) => Pair | null | boolean;
export declare let assq: (item: any, p: Pair | null) => Pair | null | boolean;
export declare let assv: (item: any, p: Pair | null) => Pair | null | boolean;
export declare let assoc: (item: any, p: Pair | null) => Pair | null | boolean;
export declare let list_copy: (p: Pair | null) => Pair | null;
export declare class _Symbol {
    sym: string;
    constructor(sym: string);
    toString(): string;
    equals(other: any): boolean;
}
export declare let symbolQ: (s: any) => boolean;
export declare let symbolEQ: (s1: any, s2: any) => boolean;
export declare let symbol_Gstring: (s: _Symbol) => string;
export declare let string_Gsymbol: (s: string) => _Symbol;
export declare let stringQ: (s: any) => boolean;
export declare let make_string: (n: number, ch?: string) => string;
export declare let string: (...args: string[]) => string;
export declare let string_length: (s: string) => number;
export declare let string_ref: (s: string, n: number) => string;
export declare let string_setB: (s: string, n: number, ch: string) => void;
export declare let stringEQ: (s1: string, s2: string) => boolean;
export declare let stringLQ: (s1: string, s2: string) => boolean;
export declare let stringGQ: (s1: string, s2: string) => boolean;
export declare let stringLEQ: (s1: string, s2: string) => boolean;
export declare let stringGEQ: (s1: string, s2: string) => boolean;
export declare let substring: (s: string, start: number, end?: number) => string;
export declare let string_append: (...args: string[]) => string;
export declare let string_Glist: (s: string) => Pair | null;
export declare let list_Gstring: (p: Pair | null) => string;
export declare let string_copy: (s: string) => string;
export declare let string_copyB: (s: string) => string;
export declare let string_fillB: (s: string, ch: string) => void;
export declare let string_map: (f: Function, s: string) => string;
export declare let string_for_each: (f: Function, s: string) => void;
export declare class Vector {
    vec: any[];
    constructor(vec: any[]);
    toString(): string;
    equals(other: any): boolean;
}
export declare let vectorQ: (v: any) => boolean;
export declare let make_vector: (n: number, fill?: any) => Vector;
export declare let vector: (...args: any[]) => Vector;
export declare let vector_length: (v: Vector) => number;
export declare let vector_ref: (v: Vector, n: number) => any;
export declare let vector_setB: (v: Vector, n: number, item: any) => void;
export declare let vector_Glist: (v: Vector) => Pair | null;
export declare let list_Gvector: (p: Pair | null) => Vector;
export declare let vector_Gstring: (v: Vector) => string;
export declare let string_Gvector: (s: string) => Vector;
export declare let vector_copy: (v: Vector) => Vector;
export declare let vector_copyB: (v: Vector) => Vector;
export declare let vector_append: (...args: Vector[]) => Vector;
export declare let vector_fillB: (v: Vector, fill: any) => void;
export declare let procedureQ: (p: any) => boolean;
export declare let apply: (proc: Function, ...args: any[]) => any;
export declare let map: (proc: Function, ...args: (Pair | null)[]) => Pair | null;
export declare let error: (msg: string) => void;
export declare let newline: () => void;
