import { AllowedDeclarations, BindableType, Chapter, ForAll, FunctionType, List, LiteralType, Pair, PredicateType, Primitive, SArray, TSBasicType, Type, TypeEnvironment, UnionType, Variable } from '../types';
import * as tsEs from './tsESTree';
export declare const NEGATIVE_OP = "-_1";
export declare const RETURN_TYPE_IDENTIFIER = "//RETURN_TYPE";
export declare const typeAnnotationKeywordToBasicTypeMap: Record<tsEs.TSTypeKeyword, TSBasicType>;
export declare function lookupType(name: string, env: TypeEnvironment): BindableType | undefined;
export declare function lookupDeclKind(name: string, env: TypeEnvironment): AllowedDeclarations | undefined;
export declare function lookupTypeAlias(name: string, env: TypeEnvironment): Type | ForAll | undefined;
export declare function setType(name: string, type: BindableType, env: TypeEnvironment): void;
export declare function setDeclKind(name: string, kind: AllowedDeclarations, env: TypeEnvironment): void;
export declare function setTypeAlias(name: string, type: Type | ForAll, env: TypeEnvironment): void;
export declare function pushEnv(env: TypeEnvironment): void;
export declare function formatTypeString(type: Type, formatAsLiteral?: boolean): string;
export declare function tPrimitive(name: Primitive['name'], value?: string | number | boolean): Primitive;
export declare function tVar(name: string, typeArgs?: Type[]): Variable;
export declare function tAddable(name: string): Variable;
export declare function tPair(headType: Type, tailType: Type): Pair;
export declare function tList(elementType: Type, typeAsPair?: Pair): List;
export declare function tForAll(polyType: Type, typeParams?: Variable[]): ForAll;
export declare function tArray(elementType: Type): SArray;
export declare const tAny: Primitive;
export declare const tBool: Primitive;
export declare const tNumber: Primitive;
export declare const tString: Primitive;
export declare const tUndef: Primitive;
export declare const tVoid: Primitive;
export declare const tNull: Primitive;
export declare function tFunc(...types: Type[]): FunctionType;
export declare function tUnion(...types: Type[]): UnionType;
export declare function tLiteral(value: string | number | boolean): LiteralType;
export declare function tPred(ifTrueType: Type | ForAll): PredicateType;
export declare const headType: Variable;
export declare const tailType: Variable;
export declare function tStream(elementType: Type): FunctionType;
export declare const predeclaredNames: [string, BindableType][];
export declare const pairFuncs: [string, BindableType][];
export declare const mutatingPairFuncs: [string, BindableType][];
export declare const arrayFuncs: [string, BindableType][];
export declare const listFuncs: [string, BindableType][];
export declare const primitiveFuncs: [string, BindableType][];
export declare const preS3equalityFuncs: [string, BindableType][];
export declare const postS3equalityFuncs: [string, BindableType][];
export declare const temporaryStreamFuncs: [string, BindableType][];
export declare const source1TypeOverrides: [string, BindableType][];
export declare const source2TypeOverrides: [string, BindableType][];
export declare const source3TypeOverrides: [string, BindableType][];
export declare const source4TypeOverrides: [string, BindableType][];
export declare function createTypeEnvironment(chapter: Chapter): TypeEnvironment;
export declare function getTypeOverrides(chapter: Chapter): [string, BindableType][];
